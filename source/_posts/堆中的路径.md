---
title: 【C】 PTA习题 05-树7 堆中的路径
date: 2019-05-04 14:31:37
tags:   
    - C
    - 堆
    - 树
    - PAT
categories:
    - 刷题
---
堆的基本操作  
https://pintia.cn/problem-sets/1077214780527620096/problems/1111280682067111936

<!--more-->
## 堆中的路径
将一系列给定数字插入一个初始为空的小顶堆H[]。随后对任意给定的下标i，打印从H[i]到根结点的路径。

输入格式:
每组测试第1行包含2个正整数N和M(≤1000)，分别是插入元素的个数、以及需要打印的路径条数。下一行给出区间[-10000, 10000]内的N个要被插入一个初始为空的小顶堆的整数。最后一行给出M个下标。

输出格式:
对输入中给出的每个下标i，在一行中输出从H[i]到根结点的路径上的数据。数字间以1个空格分隔，行末不得有多余空格。
```
输入样例:
5 3
46 23 26 24 10
5 4 3
```
```
输出样例:
24 23 10
46 23 10
26 10
```

## 分析
构建最小堆，并根据提供的下标，输出下标位置到根节点的路径  
参考数据机构第五章，堆的插入时的讲解，以及小白专场中的题解。  
插入堆时的for循环和平时写的很不一样，要结合堆的插入操作进行理解。  
详细注释见代码

## 代码
```C
#include<stdio.h>

#define MAXN 1001
#define MINH -10001

int H[MAXN], size;

void Create() {
    size = 0;
    //设置岗哨
    H[0] = MINH;
}

void Insert(int X) {
    //将X插入H
    int i;

    /*  最小堆
        i指向插入后，堆中的最后一个元素的位置
        为了满足最小堆，而不被插入的新的数据破坏，
        所以，将其向上不断比较、交换
    */
    for (i = ++size; H[i / 2] > X; i/=2)
        H[i] = H[i / 2];    //向下（数字大小）过滤节点，对于树形结构来说向上查找
    H[i] = X;   //插入
}

int main() {
    int n, m, x, i, j;

    scanf("%d %d", &n, &m);
    //堆初始化
    Create();
    //逐个插入、建堆
    for (i = 0; i < n; i++) {
        scanf("%d", &x);
        Insert(x);
    }

    for (i = 0; i < m; i++) {
        scanf("%d", &j);
        printf("%d", H[j]);
        while(j>1) {
            j /= 2;
            printf(" %d", H[j]);
        }
        printf("\n");
    }
    // for (i = 0; i <= n;i++)
    //     printf("%d ", H[i]);

    return 0;
}
```